
#version du pong ou on fixe la direction en fonction de la vitesse constante choisie....

clear temp
clear b
# adresseram
clear compteur

#taille balle (carré de coté ...)
clear demicote

# coordonnées balle (ie le centre du carré)
clear x
clear y

# taille raquette
clear demiraq

# coordonées raquette 
clear yr1
clear yr2

# vitesse
#norme de la vitesse horizontale de la balle (on considère que la vistesse horizontale est constante (vitesse qand x augmente) mais varie donc selon l'angle de la trajectoire)
clear vballe
# norme de la vitesse verticale de la raquette
clear vraq

# direction
#1 si va vers la droite, 0 si va vers la gauche
clear xbool
clear ybool 
#xbool qui dit dans quel sens on va (ie vers la droite ou vers la gauche)
#ybool qui dit si on va vers le haut ou vers le bas (par rapport au point x sur la droite ou sur la partie gauche du plateau)
#on définit m comme etant l'entier premier par lequel il va falloir faire le modulo pour créer le pseudo-aléatoire
clear m  


#on definit que la vitesse horizontale de la balle est exactement le projeté du vecteur vitesse selon l'axe des abscisses
clear dirx
#on fixe la valeur dirx comme expliqué
addr dirx dirxvballe
clear diry
#dirx est l'abscisse du point sur la plafond ou le sol de notre plateau (fixe)
#diry est l'ordonnée du point sur le coté droit ou gauche du plateau
#MODIF : diry est signé, ce qui nous perme"tde juste sommer pour se deplacer


# taille du plateau
clear taillex 
clear tailley 
#on initilisera  à la valeur : tailley = 20 000, taillex = 40 000

# aléatoire, au début sera initialisé aux seeds et sera modifié à chaque fois qu'on aura besoin de l'aléatoire
#bool pour dire si on part vers le bas ou vers le haut (le registre aleabool sera un grand chiffre aléatoire que l'onconsidère comme un booléen en prenant le bit de poid faible)
#NB : on utilise un alea de fibonacci donc on a besoin de 2 seeds...
clear aleabool 
clear aleabool_bis
clear aleay
clear aleay_bis

Init:
#création des seed pour l'aléa avec le point de départ de la clock 
rram aleabool compteur
rram aleay compteur

rram aleabool_bis compteur
rram aleay_bis compteur
#on essaie d'avoir 2 nombre différents en ajoutant un nombre à alea y
add aleay aleay 181
add aleay_bis aleay_bis 13 
add aleabool_bis aleabool_bis67
jmpf Startgame

#initialisation des valeurs 
add taillex taillex40000
add tailley tailley20000
add demicote demicote 200
#position initale de la balle : 
add x x 0
add y y 10000
add demiraq demiraq 1500
add yr1 yr1 10000
add yr2 yr2 10000
#il faudra probablement augmenter cette valeur
add vballe vballe 1000
add vraq vraq 500
#la balle commence par aller vers la droite
add xbool xbool1
add ybool ybool 0 

add m m 500
#dirx est déja initialisé plus haut à vballe
add dirx dirx 0 
#la balle commence par aller en ligne droite
add diry diry 0 




#emplacements dans la ram
Wram:
# 0 : seed
# 1 : perdu
# 2 : x
# 3 : y
# 4 : yr1
# 5 : yr2
# 6 : bouger1 (devra être sur deux bits)
# 7 : bouger2 (devra être sur deux bits)

clear compteur
#on skip la valeur de perdu qui ne nous interesse pas, on va directement à x 
add compteur compteur 2
wram x compteur
add compteur compteur 1
wram y compteur
add compteur compteur 1
wram yr1 compteur
add compteur compteur 1
wram yr2 compteur
jmpf Avancer

Startgame:
jmpf Wram

Bouger1:
#temp contient si on bouge ou non

mod_2 temp temp
jnzr temp 15

# cas où la raquette monte
addr yr1 yr1 vraq
copy temp yr1
addr temp demiraq
subr temp tailley
positif b temp
not b b
jnzf b Avancer1
copy yr1 tailley
subr yr1 demiraq
jmpf Avancer1

# cas où la raquette descend
subr yr1 vraq
copy temp yr1
subr temp demiraq
positif b temp
jnzf b Avancer1
copy yr1 demiraq
jmpf Avancer1

#cas ou la raquette ne bouge pas

Bouger2:
mod_2 temp temp
jnzr temp 15

# cas où la raquette monte
addr yr2 vraq
copy temp yr2
addr temp demiraq
subr temp tailley
positif b temp
not b b
jnzf b Avancer2
copy yr2 tailley
subr yr2 demiraq
jmpf Avancer2

# cas où la raquette descend
#on deplace le centre de la raquette vers le bas
subr yr2 vraq
#conserve sa place
copy temp yr2
#trouve le coté bas de la raquette
subr temp demiraq
#met vrai dans b si temp est vraie ie si tout va bien
positif b temp
#si b est faux (ie si tout va mal)
jnzf b Avancer2
copy yr2 demiraq
jmpf Avancer2

Avancer:
clear compteur
add compteur compteur 6
rram temp compteur
#on va bouger la raquette gauche
jnzf Bouger1

Avancer1:
add compteur compteur 1
rram temp compteur
#on va bouger la raquette droite
jnzf Bouger2

Avancer2:
copy temp x
jnzr temp 2
jmpf RaquetteGtouche

subr temp taillex
jnzr temp 2
jmpf RaquetteDtouche

copy temp y
jnzr temp 2
jmpf Bordtouche

subr temp tailley
jnzr temp 2
jmpf Bordtouche

Avancer3:



#vballe = dirx : le produit en croix est trivial
addr x vballe
#prise en charge du sens de déplacement
jnzr xbool 3
subr y diry
subr y diry

addr y diry

#verification qu'il n'y a pas de sortie du plateau 
#par le bord gauche 
positif temp x 
#si positif on saute les deux lignes, sinon on les fait
jnzr temp 3
clear x 
addr x demicote

#par le bord droit 
copy temp x 
subr temp taillex 
positif b temp 
not b b 
#si c'est negatif ie s'il y a un probleme on fait la ligne, sinon on saute
jnzr b 3
copy x taillex 
subr x demicote

#par le sol
positif temp y
jnzr temp 3
clear y  
addr y demicote

#par le plafond
copy temp y
subr temp tailley
positif b temp 
not b b 
#si c'est negatif ie s'il y a un probleme on fait la ligne, sinon on saute
jnzr b 3
copy y tailley
subr y demicote




jmpf Wram

Bordtouche:
neg diry diry
not ybool ybool
jmpf Avancer3

RaquetteGtouche:
copy temp x
subr temp demicote
jnzf temp Perdu
jmpf Rebondraquette

RaquetteDtouche:
copy temp x
addr temp demicote
subr temp taillex
jnzf temp Perdu
jmpf Rebondraquette

Rebondraquette:
alea aleabool
alea aleay
not xbool xbool
copy ybool aleabool
copy diry aleay
mod_vmaxy diry diry
jmpf Avancer

Perdu:
clear compteur
add compteur compteur 1
clear temp
not temp temp
wram temp compteur
